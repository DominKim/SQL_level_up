## 06_결합

## 기능적 관점으로 구분하는 결합의 종류
### 1. 크로스 결합 - 모든 결합의 모체
- 실무에 사용할 기회가 거의 없다.
- 크로스 결합이 실무에서 사용되지 않는 이유
  - 이러한 결과가 필요한 경우가 없다.
  - 비용이 매우 많이 드는 연산이다.
- 실수로 사용한 크로스 결합
``` sql
SELECT *
  FROM Employees, Departments;
```

### 2. 내 결합 - 왜 '내부'라는 말을 사용할까?
- 내부 결합의 작동
  - 내부 결합의 결과는 모두 크로스 결합 결과의 일부(부분집합)
내부 결합을 실행
``` sql
SELECT E.emp_id, E.emp_name, E.dept_id, D.dept_name
  FROM Employees E INNER JOIN Departments D
    ON E.dept_id = D.dept_id;
```

- 내부 결합과 같은 기능을 하는 상관 서브쿼리
  - 내부 결합은 기능적을 상관 서브쿼리를 사용해 대체 가능한 경구가 많다.
  - 기본적으로 결합을 사용하는 것이 좋다.(Why? 상관 서브쿼리르 스칼라 서브쿼리로 사용하면 겨과 레코드 수만큼 상관 서브쿼리를 실행해 비용이 꽤 높기 때문)
``` sql
SELECT E.emp_id, E.emp_name, E.dept_id,
       (SELECT D.dept_name
          FROM Departments D
         WHERE E.dept_id = D.dept_id) AS dept_name
  FROM Employees E;
```

### 3. 외부 결합 - 왜 '외부'라는 말을 사용할까?
- '내부' : 데카르트 곱의 부분 집합, '외부' : 데카르트 곱의 부분 집합이 아니다.
- 데이터 상태에 따 경우에 따라서는 데카르 곱의 부분 집합

- 외부결합의 작동
  - 왼쪽 외부 결합
  - 오른쪽 외부 결합
  - 완전 외부 결합

  - 왼쪽, 오른쪽 외부결합은 실질적으로 같은 기능을 가짐, 마스터가 되는 테이블의 기준에 따라 왼쪽, 오른쪽이 나뉘며 마스터 테이블 쪽에만 존재하는 키가 있을 때는 해당 키를 제거하지 않고 보존함

``` sql
SELECT E.emp_id, E.emp_name, E.dept_id, D.dept_name
  FROM Departments D LEFT OUTER JOIN Employees E
    ON D.dept_id = E.dept_id;
```

### 4. 외부 결합합과 내부 결합의 차이
- 외부 결합 결과가 크로스 결합 결과의 부분 집합이 아닌 이유는 이렇게, 외부 결합이 마스터 테이블의 정보르 모두 보존하고자 NULL을 생성하기 때문

### 5. 자기 결합 - '자기'란 누구일까?
- 자기 결합(self join)은 문자 그대로 자기 자신과 결합하는 연산으로, 간단하게 말하면 같은 테이블을 사용해 결합하는 것

- 자기 결합의 작동
자기 결합 + 크로스 결합
``` sql
SELECT D1.digit + (D2.digit * 10) AS seq
  FROM Digits D1 CROSS JOIN Digits D2
  ORDER BY seq;
```

- 자기 결합의 사고방식
  - 일반적으로 같은 테으블에 별칭을 붙여 마치 다른 테이블인 것처러 다룸

## 결합 알고리즘과 성능

### 1. Nested Loops
- Nested Loops의 작동
  - 이름 그대로 중첩 반복을 사용하는 알고리즘
  - Python의 이중 for문
  - Hash 또는 Sort Merge에 비해 메모리 소비가 적다.
  - 모든 DBMS에서 지원

- 구동 테이블의 중요성
  - Nested Loops의 성능을 개선하는 키워드 : 구동 테이블로는 작은 테이블을 선택
  - When? 내부 테이블의 결합 키 필드에 인덱스가 존재
  - 구동 테이블이 작은 Nested Loops + 내부 테이블의 결합 키 인덱스 (SQL 튜닝의 기본)

- Nested Loops의 단점
  - 결합 키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많은 경우
  - 대처하는 방법 : 구동 테이블로 큰 테이블을 선택하는 역설적인 방법, 해시 사용

### 2. Hash
- Hash의 작동
  - 입력에 대해 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수
  - 해시 결합 : 작은 테이블을 스캔하고, 결합 키에 해시 함수를 적용해서 해시값으로 변환
- Hast의 특징
  - 결합 테이블로부터 해시 테이블을 만들어서 활용, Nested Loops에 비해 메모리를 크게 소모
  - 메모리가 부족하며 저장소를 사용하므로 지연ㅇ 발생
  - 출력되는 해시값은 입력값의 순서를 알ㅈ 못하므로, 등치 결합에만 사용
- Hast가 유용한 경우
  - Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우
  - 내부 테이블에서 히트되느 레코드 수가 너무 많은 경우
  - Nseted Loops의 내부 테이블에 인덱스가 존재하지 않는 경우

### 3. Sort Merge
- Sort Merge의 작동
  - 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합
- Sort Merge의 특징
  - 메모리 부족으로 TEMP 탈락이 발생하면 I / O 비용이 늘어나고 지연이 발생할 위험이 있다.
  - Hash와 다르게 동치 결합뿐만 아니라 부등호를 사용하 결합에도 사용할 수 있다.
  - 원리적으로는 테이블이 결합 키로 정렬되어 있다며 정렬을 생략할 수 있다. 다만, 이는 SQL에서 테이블에 있는 레코드의 물리적인 위치를 알고 있을 때
  - 테이블을 정렬하므로 한쪽 테이블을 모두 스캔한 시점에 결합을 완료할 수 있다.
- Sort Merg가 유효하 경우
  - 테이블 정렬을 생략할 수 있는 경우에 고려

